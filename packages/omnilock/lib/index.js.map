{"version":3,"sources":["../src/index.ts"],"names":["PrivateKeySigner","constructor","privateKey","_privateKey","sign","message","hd","key","signRecoverable","Secp256k1Blake160SignableScript","userConfig","userSigner","_config","config","predefined","AGGRON4","_signer","generateSigningEntries","txSkeleton","hasher","utils","CKBHasher","signLock","inputs","get","cell_output","lock","signingEntries","update","buffer","digest","Uint8Array","digestReader","toArrayBuffer"],"mappings":";;;;;;;AAAA;;AAKA;;AACA;;AACA;;;;AA0BO,MAAMA,gBAAN,CAAyC;AAG9CC,EAAAA,WAAW,CAACC,UAAD,EAAwB;AACjC,SAAKC,WAAL,GAAmBD,UAAnB;AACD;;AAEDE,EAAAA,IAAI,CAACC,OAAD,EAAgC;AAClC,WAAOC,YAAGC,GAAH,CAAOC,eAAP,CAAuBH,OAAvB,EAAgC,KAAKF,WAArC,CAAP;AACD;;AAT6C;;;;AAYzC,MAAMM,+BAAN,CAAgE;AAIrER,EAAAA,WAAW,CAACS,UAAD,EAA6BC,UAA7B,EAAkD;AAC3D,SAAKC,OAAL,GAAeF,UAAU,IAAKG,uBAAOC,UAAP,CAAkBC,OAAhD;AACA,SAAKC,OAAL,GAAeL,UAAU,IAAI,IAAIX,gBAAJ,CAAqB,EAArB,CAA7B;AACD;;AAEDiB,EAAAA,sBAAsB,CACpBC,UADoB,EAEJ;AAAA;;AAChB,UAAMC,MAAM,GAAG,IAAIC,YAAMC,SAAV,EAAf,CADgB,CAEhB;;AACA,UAAMC,QAAQ,4BAAGJ,UAAU,CAACK,MAAX,CAAkBC,GAAlB,CAAsB,CAAtB,CAAH,0DAAG,sBAA0BC,WAA1B,CAAsCC,IAAvD;AACA,UAAMC,cAAc,GAAG,4CACrBT,UADqB,EAErB,CAACI,QAAD,CAFqB,EAGrB;AACEH,MAAAA,MAAM,EAAE;AACNS,QAAAA,MAAM,EAAGvB,OAAD,IAAkBc,MAAM,CAACS,MAAP,CAAcvB,OAAO,CAACwB,MAAtB,CADpB;AAENC,QAAAA,MAAM,EAAE,MAAM,IAAIC,UAAJ,CAAeZ,MAAM,CAACa,YAAP,GAAsBC,aAAtB,EAAf;AAFR;AADV,KAHqB,CAAvB;AAWA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI,WAAON,cAAP;AACD;;AAES,QAAJvB,IAAI,CAACC,OAAD,EAAsC;AAC9C,WAAO,MAAM,KAAKW,OAAL,CAAaZ,IAAb,CAAkBC,OAAlB,CAAb;AACD;;AA/EoE;AAkFvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import {\n  HexString,\n  utils,\n} from \"@ckb-lumos/base\";\nimport helpers from \"@ckb-lumos/helpers\";\nimport hd from \"@ckb-lumos/hd\";\nimport config from \"@ckb-lumos/config-manager\";\nimport {createP2PKHMessageGroup } from \"@ckb-lumos/common-scripts\";\n\ntype SigningEntry = {\n  // script: Script;\n  index: number;\n  // witnessArgItem: HexString;\n  // signatureOffset: number;\n  // signatureLength: number;\n  message: HexString;\n};\n\ntype Promisible<T> = T | Promise<T>;\n\ntype Signature = HexString;\n\ninterface SignableScript {\n  generateSigningEntries: (\n    tx: helpers.TransactionSkeletonType\n  ) => Promisible<SigningEntry[]>;\n  sign: (message: HexString) => Promisible<Signature>;\n}\n\ninterface Signer {\n  sign: (message: HexString) => Promisible<Signature>;\n}\n\nexport class PrivateKeySigner implements Signer {\n  private _privateKey: HexString;\n\n  constructor(privateKey: HexString) {\n    this._privateKey = privateKey;\n  }\n\n  sign(message: HexString): Signature {\n    return hd.key.signRecoverable(message, this._privateKey);\n  }\n}\n\nexport class Secp256k1Blake160SignableScript implements SignableScript {\n  private readonly _config: config.Config;\n  private readonly _signer: Signer;\n\n  constructor(userConfig?: config.Config, userSigner?: Signer) {\n    this._config = userConfig || (config.predefined.AGGRON4 as config.Config);\n    this._signer = userSigner || new PrivateKeySigner(\"\");\n  }\n\n  generateSigningEntries(\n    txSkeleton: helpers.TransactionSkeletonType\n  ): SigningEntry[] {\n    const hasher = new utils.CKBHasher();\n    // locks you want to sign\n    const signLock = txSkeleton.inputs.get(0)?.cell_output.lock!;\n    const signingEntries = createP2PKHMessageGroup(\n      txSkeleton,\n      [signLock],\n      {\n        hasher: {\n          update: (message: any) => hasher.update(message.buffer),\n          digest: () => new Uint8Array(hasher.digestReader().toArrayBuffer()),\n        },\n      }\n    );\n\n    /*\n    let signingEntries: SigningEntry[] = [];\n    const template = this._config.SCRIPTS['SECP256K1_BLAKE160'];\n    const tx = helpers.createTransactionFromSkeleton(txSkeleton);\n    const txHash = utils.ckbHash(\n      core.SerializeRawTransaction(toolkit.normalizers.NormalizeRawTransaction(tx))\n    ).serializeJson();\n    const inputs = txSkeleton.get(\"inputs\");\n    const witnesses = txSkeleton.get(\"witnesses\");\n\n    for (let i = 0; i < inputs.size; i++) {\n      const input = inputs.get(i)!;\n      if (\n        template.CODE_HASH === input.cell_output.lock.code_hash &&\n        template.HASH_TYPE === input.cell_output.lock.hash_type &&\n        !processedArgs.has(input.cell_output.lock.args)\n      ) {\n        processedArgs = processedArgs.add(input.cell_output.lock.args);\n        const lockHash = utils.computeScriptHash(input.cell_output.lock)\n        const hasher = new utils.CKBHasher();\n        hasher.update(txHash);\n        if (i >= witnesses.size) {\n          throw new Error(`Can't find witness for input ${i}, witnesses are ${witnesses.toArray()}`);\n        }\n        hashWitness(hasher, witnesses.get(i)!);\n        for (let j = i + 1; j < inputs.size && j < witnesses.size; j++) {\n          const otherInput = inputs.get(j)!;\n          if (\n            lockHash.toLowerCase() === utils.computeScriptHash(otherInput.cell_output.lock).toLowerCase()\n          ) {\n            hashWitness(hasher, witnesses.get(j)!);\n          }\n        }\n        for (let j = inputs.size; j < witnesses.size; j++) {\n          hashWitness(hasher, witnesses.get(j)!);\n        }\n        const signingEntry: SigningEntry = {\n          script: input.cell_output.lock,\n          index: i,\n          witnessArgItem: witnesses.get(i)!,\n          signatureOffset: 0,\n          signatureLength: 65,\n          message: hasher.digestHex(),\n        };\n        signingEntries = signingEntries.concat(signingEntry);\n      }\n    }\n    */\n    return signingEntries;\n  }\n\n  async sign(message: string): Promise<HexString> {\n    return await this._signer.sign(message);\n  }\n}\n\n/*\nexport function hashWitness(hasher: any, witness: HexString): void {\n  const lengthBuffer = new ArrayBuffer(8);\n  const view = new DataView(lengthBuffer);\n  const witnessHexString = BI.from(new toolkit.Reader(witness).length()).toString(16);\n  if (witnessHexString.length <= 8) {\n    view.setUint32(0, Number(\"0x\" + witnessHexString), true);\n    view.setUint32(4, Number(\"0x\" + \"00000000\"), true);\n  }\n\n  if (witnessHexString.length > 8 && witnessHexString.length <= 16) {\n    view.setUint32(0, Number(\"0x\" + witnessHexString.slice(-8)), true);\n    view.setUint32(4, Number(\"0x\" + witnessHexString.slice(0, -8)), true);\n  }\n  hasher.update(lengthBuffer);\n  hasher.update(witness);\n}\n*/\n"],"file":"index.js"}